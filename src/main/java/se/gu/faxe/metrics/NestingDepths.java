/*************************************************************
 Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements.  See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership.  The ASF licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
 *************************************************************/
package se.gu.faxe.metrics;

import com.scalified.tree.TreeNode;
import se.gu.faxe.*;

import java.io.File;
import java.io.IOException;
import java.util.*;

/**
 * Nesting depths of annotations: Maximum (MaxND), Minimum (MinND), and Average (AvgND) nesting depth of annotations
 * directly referencing the feature. Nesting depth expresses the fact, how deep a feature annotation is nested - completely
 * or partially - with another feature annotation. The depth of nesting is 1, when the annotations is neither inside
 * another textual annotation (e.g. &begin / &end) nor the containing file or any (parent-)folder contains a feature
 * annotation. Each textual, file and folder annotation increases the nesting depth by 1.
 * -> Independent of number of feature annotations to parent file/folder, depth is increased by 1
 * -> Annotations are unweighted (independent of length of fragment annotation or if file/folder mapping
 */


public class NestingDepths {
    private static final int ND_DEFAULT_VALUE = -1;
    private static double AvgND = ND_DEFAULT_VALUE;
    private static int MaxND = ND_DEFAULT_VALUE;
    private static int MinND = ND_DEFAULT_VALUE;

    /**
     * Calculate Average nesting depth: Nesting depth expresses the fact, how deep a feature annotation is
     * nested - completely or partially - with another feature annotation.
     * @param fullAssetTree Asset tree generated by FAXE to traverse for metrics
     * @param searchedPath Sub-Tree to search for data
     * @param searchFeature Searched feature name
     * @return Average nesting depth of given feature in given path.
     * @throws IOException in case searchedPath does not exist in fullAssetTree.
     */
    public static double calculateAvgND(TreeNode<Asset> fullAssetTree, File searchedPath, Feature searchFeature) throws IOException {
        return calculateAvgND(fullAssetTree, searchedPath, searchFeature, false);
    }

    /**
     * Calculate Average nesting depth: Nesting depth expresses the fact, how deep a feature annotation is
     * nested - completely or partially - with another feature annotation.
     * @param fullAssetTree Asset tree generated by FAXE to traverse for metrics
     * @param searchedPath Sub-Tree to search for data
     * @param searchFeature Searched feature name
     * @param printFoundLocation Enable print to list locations relevant to this metric.
     * @return Average nesting depth of given feature in given path.
     * @throws IOException in case searchedPath does not exist in fullAssetTree.
     */
    public static double calculateAvgND(TreeNode<Asset> fullAssetTree, File searchedPath, Feature searchFeature, boolean printFoundLocation) throws IOException {

        calculateND(fullAssetTree, searchedPath, searchFeature, printFoundLocation);

        return AvgND;
    }

    /**
     * Calculate Maximum nesting depth: Nesting depth expresses the fact, how deep a feature annotation is
     * nested - completely or partially - with another feature annotation.
     * @param fullAssetTree Asset tree generated by FAXE to traverse for metrics
     * @param searchedPath Sub-Tree to search for data
     * @param searchFeature Searched feature name
     * @return Maximum nesting depth of given feature in given path.
     * @throws IOException in case searchedPath does not exist in fullAssetTree.
     */
    public static double calculateMaxND(TreeNode<Asset> fullAssetTree, File searchedPath, Feature searchFeature) throws IOException {
        return calculateMaxND(fullAssetTree, searchedPath, searchFeature, false);
    }

    /**
     * Calculate Maximum nesting depth: Nesting depth expresses the fact, how deep a feature annotation is
     * nested - completely or partially - with another feature annotation.
     * @param fullAssetTree Asset tree generated by FAXE to traverse for metrics
     * @param searchedPath Sub-Tree to search for data
     * @param searchFeature Searched feature name
     * @param printFoundLocation Enable print to list locations relevant to this metric.
     * @return Maximum nesting depth of given feature in given path.
     * @throws IOException in case searchedPath does not exist in fullAssetTree.
     */
    public static double calculateMaxND(TreeNode<Asset> fullAssetTree, File searchedPath, Feature searchFeature, boolean printFoundLocation) throws IOException {

        calculateND(fullAssetTree, searchedPath, searchFeature, printFoundLocation);

        return MaxND;
    }

    /**
     * Calculate Minimum nesting depth: Nesting depth expresses the fact, how deep a feature annotation is
     * nested - completely or partially - with another feature annotation.
     * @param fullAssetTree Asset tree generated by FAXE to traverse for metrics
     * @param searchedPath Sub-Tree to search for data
     * @param searchFeature Searched feature name
     * @return Minimum nesting depth of given feature in given path.
     * @throws IOException in case searchedPath does not exist in fullAssetTree.
     */
    public static double calculateMinND(TreeNode<Asset> fullAssetTree, File searchedPath, Feature searchFeature) throws IOException {
        return calculateMinND(fullAssetTree, searchedPath, searchFeature, false);
    }

    /**
     * Calculate Minimum nesting depth: Nesting depth expresses the fact, how deep a feature annotation is
     * nested - completely or partially - with another feature annotation.
     * @param fullAssetTree Asset tree generated by FAXE to traverse for metrics
     * @param searchedPath Sub-Tree to search for data
     * @param searchFeature Searched feature name
     * @param printFoundLocation Enable print to list locations relevant to this metric.
     * @return Minimum nesting depth of given feature in given path.
     * @throws IOException in case searchedPath does not exist in fullAssetTree.
     */
    public static double calculateMinND(TreeNode<Asset> fullAssetTree, File searchedPath, Feature searchFeature, boolean printFoundLocation) throws IOException {

        calculateND(fullAssetTree, searchedPath, searchFeature, printFoundLocation);

        return MinND;
    }

    private static void calculateND(TreeNode<Asset> fullAssetTree, File searchedPath, Feature searchFeature, boolean printFoundLocation) throws IOException {
        // Reset to avoid values of pre-run (static methods ...)
        AvgND = ND_DEFAULT_VALUE;
        MaxND = ND_DEFAULT_VALUE;
        MinND = ND_DEFAULT_VALUE;

        if (!searchedPath.exists()) {
            throw new IOException("NestingDepths::calculateND ERROR: Given input path " + searchedPath + " not existing!");
        }

        // Reduce eaList to elements below searchedPath
        TreeNode<Asset> searchRootNode = fullAssetTree.find(new Asset(searchedPath));
        if (searchRootNode == null) {
            throw new IOException("NestingDepths::calculateND ERROR: Given inout path " + searchedPath + " not existing in fullAssetTree!");
        }
        Collection<? extends TreeNode<Asset>> preOrderedCollection = searchRootNode.preOrdered();

        // Iterate tree and gather scattering information
        List<Integer> individualNestingDepts = new ArrayList<>();
        for (TreeNode<Asset> node : preOrderedCollection) {

            List<Annotation> annotationList = node.data().getAnnotationList();
            for (int i = 0; i < annotationList.size(); i++) {
                Annotation annotation = annotationList.get(i);
                if (annotation.getLinkedFeatures().contains(searchFeature)) {

                    /*******************************************/
                    /** CALCULATE NESTING FOR FILE AND FOLDER **/
                    /*******************************************/
                    TreeNode<Asset> parent = node;  // Take the node itself to check the file annotation first
                    int fileLevel = 0;
                    while (parent != null) {
                        List<Annotation> annotationListParent = parent.data().getAnnotationList();
                        // increase level for all features above. Independent of their type and number per asset.
                        if (!annotationListParent.isEmpty()) {
                            for(Annotation parentAnnotation : annotationListParent){
                                if(parentAnnotation instanceof AnnotationFile || parentAnnotation instanceof AnnotationFolder) {
                                    // Check folder/file annotations for presence of searchedFeature
                                    for(Annotation searchedFeatureAnnotation : annotationListParent){
                                        if(searchedFeatureAnnotation.getLinkedFeatures().contains(searchFeature)){
                                            if(searchedFeatureAnnotation instanceof AnnotationFile || searchedFeatureAnnotation instanceof AnnotationFolder) {
                                                int level = 0; // Level 0 as basic file level and independent of file location
                                                individualNestingDepts.add(0);
                                                if (printFoundLocation) {
                                                    System.out.println("   Feature " + searchFeature.toString() + " with level " + level + "(fileLevel=" + fileLevel + ") found in " + node.data().getPath());
                                                }
                                            }
                                        }
                                    }
                                    //System.out.println("   Annotation in parent=" + parent.data().getPath().getAbsolutePath());
                                    fileLevel++;
                                    break; // First appearance sufficient to count file/folder
                                }
                            }
                        }
                        parent = parent.parent();
                    }
//                    System.out.println("   Annotation File has fileLevel=" +fileLevel);

                    /*************************************************/
                    /** Check in-file annotations for nesting depth **/
                    /*************************************************/
                    int textLevel = 1;
                    if (annotation.getClass().equals(AnnotationFragment.class)) {
                        // Reverse iteration from back till front
                        ListIterator<Annotation> listIterator = annotationList.listIterator(i);
                        while (listIterator.hasPrevious()) {
                            // reached current annotation. Checking level upwards
                            while (listIterator.hasPrevious()) {
                                Annotation prevAnnotation = listIterator.previous();
                                // Check if scope is overlapping
                                if (prevAnnotation.getClass().equals(AnnotationFragment.class)) {
                                    if (((AnnotationFragment) prevAnnotation).getEndline() >= ((AnnotationFragment) annotation).getStartline()) {
                                        textLevel++;
                                    }
                                } /* else {
                                        // Line annotations are not overlapped by Fragments. File and Folder have level 0.
                                } */
                            }
                        }
                        if (printFoundLocation) {
                            System.out.println("   Annotation Fragment has textLevel=" + textLevel + " at: " + ((AnnotationFragment) annotation).getStartline() + "-" + ((AnnotationFragment) annotation).getEndline());
                        }
                    } else if (annotation.getClass().equals(AnnotationLine.class)) {
                        // Reverse iteration from back till front
                        ListIterator<Annotation> listIterator = annotationList.listIterator(i);
                        // reached current annotation. Checking level upwards
                        while (listIterator.hasPrevious()) {
                            Annotation prevAnnotation = listIterator.previous();
                            // Check if scope is overlapping
                            if (prevAnnotation.getClass().equals(AnnotationFragment.class)) {
                                if (((AnnotationFragment) prevAnnotation).getEndline() >= ((AnnotationLine) annotation).getLine()) {
                                    textLevel++;
                                }
                            } /* else {
                                        // Line annotations are not overlapped by Line. File and Folder have level 0.
                            } */
                        }
                        if (printFoundLocation) {
                            System.out.println("   Annotation Line has textLevel=" + textLevel + " at: " + ((AnnotationLine) annotation).getLine());
                        }
                    }

                    int level = fileLevel + textLevel;
                    individualNestingDepts.add(level);

                    if (MinND == ND_DEFAULT_VALUE || level < MinND) {
                        MinND = level;
                    }

                    if (MaxND < level) {
                        MaxND = level;
                    }

                    if (printFoundLocation) {
                        System.out.println("   Feature " + searchFeature.toString() + " with level " + level + "(fileLevel=" + fileLevel + " textLevel=" + textLevel + ") found in " + node.data().getPath());
                    }
                }
            }
        }

        if (individualNestingDepts.size() > 0) {
            double sum = individualNestingDepts.stream().mapToDouble(Integer::intValue).sum();
            AvgND = sum / individualNestingDepts.size();
        }

        if (printFoundLocation) {
            System.out.println("   Found " + individualNestingDepts.size() + " entries with ND AVG=" + AvgND + " MAX=" + MaxND + " MIN=" + MinND);
        }

    }

    /**
     * Calculate Average over all features for average nesting depth: Nesting depth expresses the fact, how deep a feature annotation is
     * nested - completely or partially - with another feature annotation.
     * @param fullAssetTree Asset tree generated by FAXE to traverse for metrics
     * @param searchedPath Sub-Tree to search for data
     * @return Average nesting depth of given feature in given path.
     * @throws IOException in case searchedPath does not exist in fullAssetTree.
     */
    public static double calculateAvgAvgND(TreeNode<Asset> fullAssetTree, File searchedPath) throws IOException {
        return calculateAvgAvgND(fullAssetTree, searchedPath, false);
    }

    /**
     * Calculate Average over all features for average nesting depth: Nesting depth expresses the fact, how deep a feature annotation is
     * nested - completely or partially - with another feature annotation.
     * @param fullAssetTree Asset tree generated by FAXE to traverse for metrics
     * @param searchedPath Sub-Tree to search for data
     * @param printFoundLocation Enable print to list locations relevant to this metric.
     * @return Average nesting depth of given feature in given path.
     * @throws IOException in case searchedPath does not exist in fullAssetTree.
     */
    public static double calculateAvgAvgND(TreeNode<Asset> fullAssetTree, File searchedPath, boolean printFoundLocation) throws IOException {
        /**
         * GET ALL FEATURES IN GIVEN SCOPE (searchedPath)
         */
        Set<String> uniqueFeatures = NumberOfFeatures.getUniqueFeaturesSet(fullAssetTree, searchedPath /*,false*/);

        /**
         * CALCULATE AvgND PER FEATURE IN SCOPE
         */

        double sumAvgND = 0.0;
        for(String feature : uniqueFeatures){
            Feature searchFeature = new Feature(feature);
            double AvgND = calculateAvgND(fullAssetTree, searchedPath, searchFeature/*, printFoundLocation*/);
            sumAvgND += AvgND;
            if (printFoundLocation) {
                System.out.println("calculateAvgAvgND for feature \"" + searchFeature + "\" has AvgND=" + AvgND);
            }
        }

        double avgAvgND = sumAvgND / ((double) uniqueFeatures.size());
        if (printFoundLocation) {
            System.out.println("calculateAvgAvgND total average AvgND = " + avgAvgND +" (sumAvgND=" +sumAvgND +" ; uniqueFeatures.size=" +uniqueFeatures.size() +")");
        }
        return avgAvgND;
    }

}