/*************************************************************
 Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements.  See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership.  The ASF licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
 *************************************************************/
package se.gu.faxe.metrics;

import com.scalified.tree.TreeNode;
import se.gu.faxe.*;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

/**
 * Nesting depths of annotations: Maximum (MaxND), Minimum (MinND), and Average (AvgND) nesting depth of annotations
 * directly referencing the feature. Nesting depth expresses the fact, how deep a feature annotation is nested - completely
 * or partially - with another feature annotation. The depth of nesting is 0, when the annotations is neither inside
 * another textual annotation (e.g. &begin / &end) nor the containing file or any (parent-)folder contains a feature
 * annotation. Each textual, file and folder annotation increases the nesting depth by 1.
 * -> Independent of number of feature annotations to parent file/folder, depth is increased by 1
 */


public class NestingDepths {
    private static double AvgND = 0;
    private static int MaxND = 0;
    private static int MinND = 0;

    /**
     * Calculate Average nesting depth: Nesting depth expresses the fact, how deep a feature annotation is
     * nested - completely or partially - with another feature annotation.
     * @param fullAssetTree Asset tree generated by FAXE to traverse for metrics
     * @param searchedPath Sub-Tree to search for data
     * @param searchFeature Searched feature name
     * @return Average nesting depth of given feature in given path.
     * @throws IOException in case searchedPath does not exist in fullAssetTree.
     */
    public static double calculateAvgND(TreeNode<Asset> fullAssetTree, File searchedPath, Feature searchFeature) throws IOException {
        return calculateAvgND(fullAssetTree, searchedPath, searchFeature, false);
    }

    /**
     * Calculate Average nesting depth: Nesting depth expresses the fact, how deep a feature annotation is
     * nested - completely or partially - with another feature annotation.
     * @param fullAssetTree Asset tree generated by FAXE to traverse for metrics
     * @param searchedPath Sub-Tree to search for data
     * @param searchFeature Searched feature name
     * @param printFoundLocation Enable print to list locations relevant to this metric.
     * @return Average nesting depth of given feature in given path.
     * @throws IOException in case searchedPath does not exist in fullAssetTree.
     */
    public static double calculateAvgND(TreeNode<Asset> fullAssetTree, File searchedPath, Feature searchFeature, boolean printFoundLocation) throws IOException {

        calculateND(fullAssetTree, searchedPath, searchFeature, printFoundLocation);

        return AvgND;
    }

    /**
     * Calculate Maximum nesting depth: Nesting depth expresses the fact, how deep a feature annotation is
     * nested - completely or partially - with another feature annotation.
     * @param fullAssetTree Asset tree generated by FAXE to traverse for metrics
     * @param searchedPath Sub-Tree to search for data
     * @param searchFeature Searched feature name
     * @return Maximum nesting depth of given feature in given path.
     * @throws IOException in case searchedPath does not exist in fullAssetTree.
     */
    public static double calculateMaxND(TreeNode<Asset> fullAssetTree, File searchedPath, Feature searchFeature) throws IOException {
        return calculateMaxND(fullAssetTree, searchedPath, searchFeature, false);
    }

    /**
     * Calculate Maximum nesting depth: Nesting depth expresses the fact, how deep a feature annotation is
     * nested - completely or partially - with another feature annotation.
     * @param fullAssetTree Asset tree generated by FAXE to traverse for metrics
     * @param searchedPath Sub-Tree to search for data
     * @param searchFeature Searched feature name
     * @param printFoundLocation Enable print to list locations relevant to this metric.
     * @return Maximum nesting depth of given feature in given path.
     * @throws IOException in case searchedPath does not exist in fullAssetTree.
     */
    public static double calculateMaxND(TreeNode<Asset> fullAssetTree, File searchedPath, Feature searchFeature, boolean printFoundLocation) throws IOException {

        calculateND(fullAssetTree, searchedPath, searchFeature, printFoundLocation);

        return MaxND;
    }

    /**
     * Calculate Minimum nesting depth: Nesting depth expresses the fact, how deep a feature annotation is
     * nested - completely or partially - with another feature annotation.
     * @param fullAssetTree Asset tree generated by FAXE to traverse for metrics
     * @param searchedPath Sub-Tree to search for data
     * @param searchFeature Searched feature name
     * @return Minimum nesting depth of given feature in given path.
     * @throws IOException in case searchedPath does not exist in fullAssetTree.
     */
    public static double calculateMinND(TreeNode<Asset> fullAssetTree, File searchedPath, Feature searchFeature) throws IOException {
        return calculateMinND(fullAssetTree, searchedPath, searchFeature, false);
    }

    /**
     * Calculate Minimum nesting depth: Nesting depth expresses the fact, how deep a feature annotation is
     * nested - completely or partially - with another feature annotation.
     * @param fullAssetTree Asset tree generated by FAXE to traverse for metrics
     * @param searchedPath Sub-Tree to search for data
     * @param searchFeature Searched feature name
     * @param printFoundLocation Enable print to list locations relevant to this metric.
     * @return Minimum nesting depth of given feature in given path.
     * @throws IOException in case searchedPath does not exist in fullAssetTree.
     */
    public static double calculateMinND(TreeNode<Asset> fullAssetTree, File searchedPath, Feature searchFeature, boolean printFoundLocation) throws IOException {

        calculateND(fullAssetTree, searchedPath, searchFeature, printFoundLocation);

        return MinND;
    }

    private static boolean calculateND(TreeNode<Asset> fullAssetTree, File searchedPath, Feature searchFeature, boolean printFoundLocation) throws IOException {
        // Reset to avoid values of pre-run (static methods ...)
        AvgND = 0;
        MaxND = 0;
        MinND = 0;

        if (!searchedPath.exists()) {
            throw new IOException("NestingDepths::calculateND ERROR: Given input path " + searchedPath + " not existing!");
        }

        // Reduce eaList to elements below searchedPath
        TreeNode<Asset> searchRootNode = fullAssetTree.find(new Asset(searchedPath));
        if (searchRootNode == null) {
            throw new IOException("NestingDepths::calculateND ERROR: Given inout path " + searchedPath + " not existing in fullAssetTree!");
        }

        // Iterate tree and gather scattering information
        List<Integer> individualNestingDepts = new ArrayList<Integer>();
        for (TreeNode<Asset> node : searchRootNode) {

            List<Annotation> annotationList = node.data().getAnnotationList();
            for (int i = 0; i < annotationList.size(); i++) {
                Annotation annotation = annotationList.get(i);
                if (annotation.getLinkedFeatures().contains(searchFeature)) {

                    /*******************************************/
                    /** CALCULATE NESTING FOR FILE AND FOLDER **/
                    /*******************************************/
                    TreeNode<Asset> parent = node.parent();
                    int fileLevel = 0;
                    while (parent != null) {
                        List<Annotation> annotationListParent = parent.data().getAnnotationList();
                        // increase level for all features above. Independent of their type and number per asset.
                        if (!annotationListParent.isEmpty()) {
                            //System.out.println("   Annotation in parent=" +parent.data().getPath().getAbsolutePath());
                            fileLevel++;
                        }
                        parent = parent.parent();
                    }
//                    System.out.println("   Annotation File has fileLevel=" +fileLevel);

                    /*************************************************/
                    /** Check in-file annotations for nesting depth **/
                    /*************************************************/
                    int textLevel = 0;
                    if (annotation.getClass().equals(AnnotationFragment.class)) {
                        // Reverse iteration from back till front
                        ListIterator<Annotation> listIterator = annotationList.listIterator(i);
                        while (listIterator.hasPrevious()) {
                            // reached current annotation. Checking level upwards
                            while (listIterator.hasPrevious()) {
                                Annotation prevAnnotation = listIterator.previous();
                                // Check if scope is overlapping
                                if (prevAnnotation.getClass().equals(AnnotationFragment.class)) {
                                    if (((AnnotationFragment) prevAnnotation).getEndline() >= ((AnnotationFragment) annotation).getStartline()) {
                                        textLevel++;
                                    }
                                } /* else {
                                        // Line annotations are not overlapped by Fragments. File and Folder have level 0.
                                } */
                            }
                            if (printFoundLocation) {
                                System.out.println("   Annotation Fragment has textLevel=" + textLevel + " at: " + ((AnnotationFragment) annotation).getStartline() + "-" + ((AnnotationFragment) annotation).getEndline());
                            }
                        }
                    } else if (annotation.getClass().equals(AnnotationLine.class)) {
                        // Reverse iteration from back till front
                        ListIterator<Annotation> listIterator = annotationList.listIterator(i);
                        // reached current annotation. Checking level upwards
                        while (listIterator.hasPrevious()) {
                            Annotation prevAnnotation = listIterator.previous();
                            // Check if scope is overlapping
                            if (prevAnnotation.getClass().equals(AnnotationFragment.class)) {
                                if (((AnnotationFragment) prevAnnotation).getEndline() >= ((AnnotationLine) annotation).getLine()) {
                                    textLevel++;
                                }
                            } /* else {
                                        // Line annotations are not overlapped by Line. File and Folder have level 0.
                            } */
                        }
                        if (printFoundLocation) {
                            System.out.println("   Annotation Line has textLevel=" + textLevel + " at: " + ((AnnotationLine) annotation).getLine());
                        }
                    }


                    int level = fileLevel + textLevel;
                    individualNestingDepts.add(level);

                    if (MinND == 0 || level < MinND) {
                        MinND = level;
                    }

                    if (MaxND < level) {
                        MaxND = level;
                    }

                    if (printFoundLocation) {
                        System.out.println("   Feature " + searchFeature.toString() + " with level " + level + "(fileLevel=" + fileLevel + " textLevel=" + textLevel + ") found in " + node.data().getPath());
                    }
                }
            }
        }

        if (individualNestingDepts.size() > 0) {
            Double sum = individualNestingDepts.stream().mapToDouble(Integer::intValue).sum();
            AvgND = sum / individualNestingDepts.size();
        }

        if (printFoundLocation) {
            System.out.println("   Found " + individualNestingDepts.size() + " entries with ND AVG=" + AvgND + " MAX=" + MaxND + " MIN=" + MinND);
        }

        return true;
    }
}